// Al final de este archivo hay un ejemplo de middlewares usando js vanilla

err.name: El nombre del error, útil para identificar el tipo de error.
err.message: El mensaje de error detallado.
err.code: El código de error, si existe. Por ejemplo, los errores de duplicado de Mongoose tienen un código de 11000.
err.status: El código de estado HTTP asociado con el error, si existe.
err.errors: En el caso de errores de validación de Mongoose, esta propiedad contiene detalles adicionales sobre los errores de validación.
err.stack: Muestra la pila de llamadas

req.body: Contiene los datos enviados por el cliente en el cuerpo de la solicitud, es especialmente relevante en solicitudes POST y PUT.
req.params: Contiene los parámetros de ruta en la URL de la solicitud. Por ejemplo, en la ruta /users/:id, puedes acceder al id con req.params.id.
req.query: Contiene los parámetros de consulta en la URL de la solicitud. Por ejemplo, en la URL /users?name=John, puedes acceder al nombre con req.query.name.
req.method: Contiene el método HTTP de la solicitud (por ejemplo, GET, POST, PUT, DELETE).
req.path: Contiene la ruta de la solicitud.

res.send(): Envía una respuesta al cliente. Puede aceptar una cadena, un objeto, un Buffer, un array, etc.
res.json(): Envía una respuesta JSON al cliente. Es similar a res.send() pero convierte automáticamente el argumento a JSON.
res.status(): Establece el código de estado HTTP de la respuesta.
res.set(): Establece los encabezados HTTP de la respuesta.
res.locals: Un objeto que contiene variables locales para la respuesta. Puedes usarlo para pasar datos entre middleware y plantillas de vistas.

console.log(`err.name ${err.name}`);
console.log(`err.message ${err.message}`);
console.log(`err.code ${err.code}`);
console.log(`err.status ${err.status}`);
console.log(`err.errors ${err.errors}`);
console.log(`--------------------------`);
console.log(`req.body ${req.body}`);
console.log(`req.params ${req.params}`);
console.log(`req.query ${req.query}`);
console.log(`req.method ${req.method}`);
console.log(`req.path ${req.path}`);
console.log(`--------------------------`);
res.send()
res.json()
res.status()
res.set()
res.locals

// EJEMPLO funcionamento middlewares js vanilla
console.clear();

const applyMiddleware = (mainFn, ...middlewares) => {
  console.log("applyMiddleware");
  return middlewares.reduceRight((next, middleware, index) => {
    console.log("  applyMiddleware return function");
    // esta funcion que se devuelve, es el next de la siguiente iteracion, de tal manera que al
    //  final obtendremos una funcion que contiene el resto, ver ejem. al final
    return () => {
      console.log("    applyMiddleware exec function");
      middleware(next);
    };
  }, mainFn);
};

const middleware1 = (next) => {
  console.log("middleware1");
  // si hiciera falta enviar datos al siguiente next, con este sistema no valdria
  // esto es solo un ejemplo sencillo de como montar un sistema de middlewares con js nativo
  // para enviar datos en el next habria que usar otro sistema de composicion de funciones
  next();
};

const middleware2 = (next) => {
  console.log("middleware2");
  next();
};

const mainFn = () => {
  console.log("mainFn");
};

// esto obtiene una funcion compuesta, en este caso:
//   middleware1(middleware2(mainFn))
const result = applyMiddleware(mainFn, middleware1, middleware2);
result();
